                 -- Day 6
-- union and union all 
/*
create table employees(
id int auto_increment primary key,
first_name varchar(50),
last_name varchar(50),
position varchar(50)
);

create table contractors(
id int auto_increment primary key,
first_name varchar(50),
last_name varchar(50),
position varchar(50)
);

Insert into employees(first_name,last_name,position)
values('Alice','s','dev ops'),
('bob','A','manager'),
('charlie','P','dev ops');

Insert into contractors(first_name,last_name,position)
values('Dave','W','dev ops'),
('eve','P','dev ops'),
('bob','A','manager');

select first_name,last_name,position from employees
union all -- in both table must have a same column count,coln name whaterver it is fine
select first_name,last_name,position from contractors;
-- datatypes must be compatable 

select first_name,last_name,position from employees
union  -- remove duplicates
select first_name,last_name,position  from contractors;

select * from employees
union -- bos is name but id is diff so it doesnt remove
select * from contractors;

-- removing duplicates - deduplication

-- in employees table we havce id, first_name,last_name,position but  in contractors table we have id and first_name alone
-- we can still use union but it works only if we have to sel id and first_name alone
-- to inc performance (index,partition)
-- index (usefull in performance optimization) - how we can optimize the performance of the queries
-- it uses b-tree data structure

create table customers(
id int auto_increment primary key,
first_name varchar(50),
last_name varchar(50),
email varchar(50),
city varchar(50)
);
-- index can be created on a column
create index idx_email on customers (email);


Insert into customers(first_name,last_name,email,city)
values('Alice','s','alice@gmail.com','chennai'),
('bob','A','bob@gmail.com','tirupur'),
('charlie','P','charlie@gmail.com','erode');

select *from customers where email='bob@gmail.com';

-- explain
explain
select *from customers where email='bob@gmail.com';
 -- analyze
explain analyze
select *from customers where email='bob@gmail.com';
-- without using index time to execute the query is so long, [watch : 5:08:00]

explain format = JSON
select *from customers where email='bob@gmail.com';
*/ 
-- partition
-- In Mysql [types of parition : range,list,hash]

create table order1(
id int auto_increment,
order_date date,
name varchar(30),
department varchar(40),
primary key(id,order_date,department)
)
-- in HIVE there is a concept called dynamic partition - automatically it will create the partition
-- Mysql is a static partiton
partition by range(year(order_date)) (
partition p_before_2020 values less than (2020),
partition p_2020 values less than (2021),
partition p_future values less than maxvalue
); 
/*
-- we need to manually add new partition
Alter table orders
add partition(
partition p_2021 values less than (2022)
);
*/

Insert into order1(order_date,name,department)
values('2019-05-10','alice','sales'),
('2019-01-10','bob','hr'),
('2021-05-10','eve','engineering'),
('2022-05-10','diana','arts'),
('2020-05-10','charlie','govn');
-- partiton pruning - is partition works
-- select *from order1;
-- we can write instead of * as partition_name,partition_method,partition_expression,subpartition_method,subpartition_schema
select *
from information_schema.partitions 
where table_schema = 'sandbox_db' 
and table_name = 'order1'; -- here not working


-- SHOW CREATE TABLE `order1`;

/*
!50100 PARTITION BY RANGE (YEAR(`order_date`))
(PARTITION p_before_2020 VALUES LESS THAN (2020) ENGINE = InnoDB,
 PARTITION p_2020 VALUES LESS THAN (2021) ENGINE = InnoDB,
 PARTITION p_future VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
-- This confirms the table is partitioned by the year of order_date.

-- SELECT DATABASE();
-- SHOW TABLES;
select * from order1 where year(order_date)  = 2020;
 -- to see partition purning is working or not
explain 
select * from order1 where order_date  ='2019-01-10';

-- list partition
/*
partition by list columns(department) (
partition p_sales values in ('sales'),
partition p_hr values in ('hr')
); -- error 

select * from order1 where department = 'sales';

explain
select * from order1 where department in ('sales','hr)';
*/ 

-- hash partition
-- acc_num, phone_number,customer_id - these are already unique how we can grp in that scenerio hash 

CREATE TABLE sensor_data (
    id INT NOT NULL,
    reading_time DATETIME NOT NULL,
    PRIMARY KEY(id, reading_time)
)
PARTITION BY HASH(id)
PARTITIONS 4;

Insert into sensor_data(id,reading_time)
values (11,'2023-07-22 14:30:00'),
(12,'2024-03-22 15:30:00'),
(35,'2023-03-11 15:30:00');

explain
select * from sensor_data where id = 35;
 -- partition vs index : watch 5:40:50