              -- Day 8 
              
-- Normalization 
-- Before (1NF)
-- Non-1NF Table: contains multi-valued phone_numbers in a single column
/*
CREATE TABLE Students_Non1NF (
student_id INT,
student_name VARCHAR(100),
phone_numbers VARCHAR(100) -- e.g., '123-4567,987-6543'
);

INSERT INTO Students_Non1NF (student_id, student_name, phone_numbers)
VALUES (1, 'Alice', '123-4567,987-6543'),
(2, 'Bob', '555-1212');

select * from Students_Non1NF;


-- After 
-- Main Students table with atomic values
CREATE TABLE Students (
student_id INT PRIMARY KEY,
student_name VARCHAR(100)
);
-- Separate table for phone numbers, ensuring each phone number

CREATE TABLE StudentPhones (
student_id INT,
phone VARCHAR (20),
PRIMARY KEY (student_id, phone),
FOREIGN KEY (student_id) REFERENCES Students (student_id)
);

INSERT INTO Students (student_id, student_name)
VALUES (1, 'Alice'),
(2, 'Bob');
-- Insert phone numbers (each phone number in its own row)
INSERT INTO StudentPhones (student_id, phone)
VALUES (1, '123-4567'),
(1, '987-6543'),
(2, '555-1212'); 

select * from Students;
select * from StudentPhones; -- if we need to chech how many phone_numbers does individual student have , we can achieve by using joina

*/
-- drop table if exists Students 
-- we can able to remove existing table if exists
/*
-- 2NF
-- Before
-- This table is in 1NF but not in 2NF because course details depend only on course_id.

CREATE TABLE Enrollment_Non2NF (
student_id INT,
course_id INT,
course_name VARCHAR(100),
instructor VARCHAR(100),
PRIMARY KEY (student_id, course_id)
);

Insert into Enrollment_Non2NF(student_id,course_id,course_name,instructor)
VALUES
(1, 101, 'Database Systems', 'Dr. Smith'),
(1, 102, 'Operating Systems', 'Dr. Johnson'),
(2, 101, 'Database Systems', 'Dr. Smith');

select * from Enrollment_Non2NF;

-- here course_name and instructor only deponds on course_id alone not a student_id

-- after 

CREATE TABLE Courses(
course_id INT primary key,
course_name VARCHAR(100),
instructor VARCHAR(100)
);


CREATE TABLE Enrollment(
student_id INT,
course_id INT,
PRIMARY KEY (student_id, course_id), -- composite key
FOREIGN KEY (course_id) REFERENCES Courses (course_id)
);

INSERT INTO Courses (course_id, course_name, instructor)
VALUES
(101, 'Database Systems', 'Dr. Smith'),
(102, 'Operating Systems', 'Dr. Johnson');

INSERT INTO Enrollment (student_id, course_id)
VALUES
(1, 101),
(1, 102),
(2, 101);

select * from Courses;
select * from Enrollment;
*/
/*
         -- 3NF
-- Before
-- This table is in 2NF but has a transitive dependency:
CREATE TABLE Courses_Non3NF (
course_id INT PRIMARY KEY,
course_name VARCHAR(100),
instructor VARCHAR(100),
instructor_office VARCHAR(100)
);

INSERT INTO Courses_Non3NF (course_id, course_name, instructor, instructor_office)
VALUES (101, 'Intro to SQL', 'Dr. Smith', 'Room 101'),
(102, 'Database Design', 'Dr. Jones', 'Room 102');

select * from Courses_Non3NF;

-- here instructor_office(non-primay key) is dependent on instructor which is also a non-primary key , instructor_office is not dependent on primary key(course_id)

-- after

CREATE TABLE Instructors6 (
instructor VARCHAR(100) PRIMARY KEY,
instructor_office VARCHAR(100)
);

CREATE TABLE Courses6 (
course_id INT PRIMARY KEY,
course_name VARCHAR(100),
instructor VARCHAR(100),
FOREIGN KEY (instructor) REFERENCES Instructors6(instructor)
);

INSERT INTO Instructors6 (instructor, instructor_office)
VALUES ('Dr. Smith', 'Room 101');

INSERT INTO Courses6 (course_id, course_name, instructor)
VALUES (101, 'Intro to SQL', 'Dr. Smith');

select * from Instructors6;
select * from Courses6;

-- if we need to get information of all these columns we can perfrom using joins
*/
             
                               -- SCD(Another data modeling)
-- -- type 1 eg
CREATE TABLE dim_product_type1 (
product_id INT PRIMARY KEY,
product_title VARCHAR(255),
category VARCHAR(100),
brand VARCHAR(100)
);

INSERT INTO dim_product_type1 (product_id, product_title, category, brand)
VALUES (101, 'Amazon Echo Dot 3rd Gen', 'Smart Speakers', 'Amazon' ) ;

select * from dim_product_type1;

UPDATE dim_product_type1 
SET product_title = 'Amazon Echo Dot (3rd Gen)'
WHERE product_id = 101;
          
select * from dim_product_type1;

-- type 2 eg
CREATE TABLE dim_seller_type2 (
seller_key INT PRIMARY KEY,
seller_id INT,
seller_name VARCHAR(255),
store_location VARCHAR(255),
effective_date DATE,
end_date DATE,
is_current BOOLEAN
);

INSERT INTO dim_seller_type2 (seller_key, seller_id, seller_name, store_location, effective_date, end_date, is_current)
VALUES (1, 501, 'Best Sellers Inc.', 'Seattle, WA', '2022-01-01', NULL, TRUE);

select * from dim_seller_type2;

UPDATE dim_seller_type2
SET end_date = '2023-01-15',
is_current = FALSE
WHERE seller_id = 501 AND is_current = TRUE;

select * from dim_seller_type2;

INSERT INTO dim_seller_type2 (seller_key, seller_id, seller_name, store_location, effective_date, end_date, is_current)
VALUES (2, 501, 'Best Sellers Inc.', 'Los Angeles, CA', '2023-01-15', NULL, TRUE);

select * from dim_seller_type2 WHERE seller_id = 501;

-- type 3 eg

CREATE TABLE dim_product_type3 (
product_id INT PRIMARY KEY,
product_title VARCHAR(255),
current_category VARCHAR(100),
previous_category VARCHAR (100)
);

INSERT INTO dim_product_type3 (product_id, product_title, current_category, previous_category)
VALUES (201, 'Amazon Fire TV Stick', 'Streaming Devices', NULL);

select * from dim_product_type3;

UPDATE dim_product_type3
SET previous_category = current_category,
current_category = 'Media Players'
WHERE product_id = 201;

select * from dim_product_type3;

-- not covered topics : Dimension Table and Fact Table


